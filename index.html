<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>å·´å£«åˆ°é” - KMB / CTB Bus Tracker</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    *{margin:0;padding:0;box-sizing:border-box;}
    :root{--primary-color:#2563eb;--primary-dark:#1d4ed8;--secondary-color:#10b981;--secondary-dark:#059669;--accent-color:#f59e0b;--background-color:#f8fafc;--surface-color:#ffffff;--text-primary:#1f2937;--text-secondary:#6b7280;--text-muted:#9ca3af;--border-color:#e5e7eb;--shadow-sm:0 1px 2px 0 rgb(0 0 0 / 0.05);--shadow-md:0 4px 6px -1px rgb(0 0 0 / 0.1),0 2px 4px -2px rgb(0 0 0 / 0.1);--shadow-lg:0 10px 15px -3px rgb(0 0 0 / 0.1),0 4px 6px -4px rgb(0 0 0 / 0.1);--radius-sm:.375rem;--radius-md:.5rem;--radius-lg:.75rem;--radius-xl:1rem;}
    body{font-family:'Inter',-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;padding:1rem;color:var(--text-primary);line-height:1.6;}
    .container{max-width:480px;margin:0 auto;background:var(--surface-color);border-radius:var(--radius-xl);box-shadow:var(--shadow-lg);overflow:hidden;animation:slideUp .6s ease-out;}
    @keyframes slideUp{from{opacity:0;transform:translateY(30px);}to{opacity:1;transform:translateY(0);}}
    .header{background:linear-gradient(135deg,var(--primary-color) 0%,var(--primary-dark) 100%);color:#fff;padding:2rem 1.5rem 1.5rem;text-align:center;position:relative;overflow:hidden;}
    .header::before{content:'';position:absolute;top:-50%;left:-50%;width:200%;height:200%;background:radial-gradient(circle,rgba(255,255,255,.1) 0%,transparent 70%);animation:pulse 4s ease-in-out infinite;}
    @keyframes pulse{0%,100%{transform:scale(1);opacity:.5;}50%{transform:scale(1.1);opacity:.8;}}
    .header h1{font-size:1.75rem;font-weight:700;margin-bottom:.5rem;position:relative;z-index:1;}
    .header p{font-size:.875rem;opacity:.9;position:relative;z-index:1;}
    .content{padding:1.5rem;}
    .form-group{margin-bottom:1.5rem;}
    .form-label{display:block;font-size:.875rem;font-weight:600;color:var(--text-primary);margin-bottom:.5rem;}
    .form-input,.form-select{width:100%;padding:.875rem 1rem;border:2px solid var(--border-color);border-radius:var(--radius-md);font-size:1rem;background:var(--surface-color);transition:all .2s ease;appearance:none;}
    .form-input:focus,.form-select:focus{outline:none;border-color:var(--primary-color);box-shadow:0 0 0 3px rgba(37,99,235,.1);}
    .form-select{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");background-position:right .75rem center;background-repeat:no-repeat;background-size:1.5em 1.5em;padding-right:2.5rem;}
    .form-select:disabled{background-color:#f9fafb;color:var(--text-muted);cursor:not-allowed;}
    .destination-display{background:linear-gradient(135deg,#f0f9ff 0%,#e0f2fe 100%);border:2px solid #bae6fd;border-radius:var(--radius-md);padding:.875rem 1rem;font-size:1rem;color:var(--primary-dark);font-weight:500;min-height:3.25rem;display:flex;align-items:center;transition:all .2s ease;}
    .destination-display.empty{color:var(--text-muted);background:#f9fafb;border-color:var(--border-color);}
    .button-group{display:flex;gap:.75rem;margin-top:1rem;}
    .btn{padding:.75rem 1.5rem;border:none;border-radius:var(--radius-md);font-size:.875rem;font-weight:600;cursor:pointer;transition:all .2s ease;display:inline-flex;align-items:center;justify-content:center;gap:.5rem;text-decoration:none;}
    .btn-primary{background:linear-gradient(135deg,var(--primary-color) 0%,var(--primary-dark) 100%);color:#fff;box-shadow:var(--shadow-sm);}
    .btn-primary:hover{transform:translateY(-1px);box-shadow:var(--shadow-md);}
    .btn-secondary{background:var(--surface-color);color:var(--text-primary);border:2px solid var(--border-color);}
    .btn-secondary:hover{background:#f9fafb;border-color:var(--text-muted);}
    .btn:disabled{opacity:.5;cursor:not-allowed;transform:none!important;}
    .status-message{padding:1rem;border-radius:var(--radius-md);margin-bottom:1rem;font-size:.875rem;font-weight:500;display:none;animation:fadeIn .3s ease;}
    @keyframes fadeIn{from{opacity:0;transform:translateY(-10px);}to{opacity:1;transform:translateY(0);}}
    .status-success{background:#ecfdf5;color:#065f46;border:1px solid #a7f3d0;}
    .status-error{background:#fef2f2;color:#991b1b;border:1px solid #fecaca;}
    .status-info{background:#eff6ff;color:#1e40af;border:1px solid #bfdbfe;}
    .route-info{background:linear-gradient(135deg,#f0f9ff 0%,#e0f2fe 100%);border:1px solid #bae6fd;border-radius:var(--radius-md);padding:1rem;margin-bottom:1rem;display:none;}
    .route-info.show{display:block;animation:slideDown .3s ease;}
    @keyframes slideDown{from{opacity:0;transform:translateY(-10px);}to{opacity:1;transform:translateY(0);}}
    .route-info h3{font-size:1rem;font-weight:600;color:var(--primary-dark);margin-bottom:.5rem;}
    .route-info p{font-size:.875rem;color:var(--text-secondary);margin:0;}
    .eta-container{background:var(--surface-color);border-radius:var(--radius-md);border:1px solid var(--border-color);overflow:hidden;}
    .eta-item{padding:1rem;border-bottom:1px solid var(--border-color);display:flex;justify-content:space-between;align-items:center;transition:background-color .2s ease;}
    .eta-item:last-child{border-bottom:none;}
    .eta-item:hover{background:#f9fafb;}
    .eta-time{font-size:1.125rem;font-weight:600;color:var(--primary-color);}
    .eta-countdown{font-size:.875rem;color:var(--text-secondary);}
    .eta-status{font-size:.75rem;color:var(--text-muted);margin-top:.25rem;}
    .loading-spinner{display:none;text-align:center;padding:2rem;}
    .loading-spinner.show{display:block;}
    .spinner{width:2rem;height:2rem;border:3px solid var(--border-color);border-top:3px solid var(--primary-color);border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 1rem;}
    @keyframes spin{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}
    .loading-text{color:var(--text-secondary);font-size:.875rem;}
    .empty-state{text-align:center;padding:3rem 1rem;color:var(--text-muted);}
    .empty-state svg{width:4rem;height:4rem;margin:0 auto 1rem;opacity:.5;}
    @media (max-width:640px){body{padding:.5rem;}.container{border-radius:var(--radius-lg);}.header{padding:1.5rem 1rem 1rem;}.header h1{font-size:1.5rem;}.content{padding:1rem;}.button-group{flex-direction:column;}.btn{width:100%;}}
    @media (prefers-reduced-motion:reduce){*,*::before,*::after{animation-duration:.01ms!important;animation-iteration-count:1!important;transition-duration:.01ms!important;}}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ğŸšŒ å·´å£«åˆ°é”</h1>
      <p>æ™ºèƒ½å·´å£«åˆ°ç«™æ™‚é–“æŸ¥è©¢ï¼ˆKMB / åŸå·´ CTBï¼‰</p>
    </div>

    <div class="content">
      <div class="form-group">
        <label for="r" class="form-label">å·´å£«è·¯ç·š</label>
        <input list="routes" id="r" class="form-input" placeholder="è«‹è¼¸å…¥å·´å£«è·¯ç·šè™Ÿç¢¼" />
        <datalist id="routes"></datalist>
      </div>

      <div class="form-group">
        <label for="destination" class="form-label">ç›®çš„åœ°</label>
        <div id="destination" class="destination-display empty">è«‹å…ˆé¸æ“‡å·´å£«è·¯ç·š</div>
        <div class="button-group">
          <button id="toggle" class="btn btn-secondary" disabled>ğŸ”„ åˆ‡æ›ç›®çš„åœ°</button>
          <button id="toggleCompany" class="btn btn-secondary" disabled>ğŸ¢ å…¬å¸: è‡ªå‹•</button>
        </div>
      </div>

      <div class="form-group">
        <label for="s" class="form-label">å·´å£«ç«™</label>
        <select id="s" class="form-select">
          <option value="">è«‹å…ˆé¸æ“‡è·¯ç·šå’Œç›®çš„åœ°</option>
        </select>
      </div>

      <div id="status" class="status-message"></div>
      <div id="i" class="route-info"></div>

      <div id="loading" class="loading-spinner">
        <div class="spinner"></div>
        <div class="loading-text">æ­£åœ¨è¼‰å…¥...</div>
      </div>

      <div id="e" class="eta-container" style="display:none;"></div>

      <div id="empty" class="empty-state" style="display:none;">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <p>è«‹é¸æ“‡å·´å£«è·¯ç·šå’Œç«™é»ä»¥æŸ¥çœ‹åˆ°ç«™æ™‚é–“</p>
      </div>
    </div>
  </div>

  <script>
    const el = (id) => document.getElementById(id);

    const makeOption = (value, text, seq) => {
      const o = document.createElement('option');
      o.value = value;
      o.textContent = text;
      if (seq !== undefined) o.dataset.seq = String(seq);
      return o;
    };

    // ---- Shared helpers ----
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function showStatus(message, type = 'info') {
      const status = el('status');
      status.textContent = message;
      status.className = `status-message status-${type}`;
      status.style.display = 'block';
      setTimeout(() => { status.style.display = 'none'; }, 5000);
    }

    function setLoading(show) {
      const loading = el('loading');
      loading.className = show ? 'loading-spinner show' : 'loading-spinner';
    }

    function formatEtaBlock(etaIso, dataTsIso, remark) {
      if (!etaIso) {
        return { timeText: 'çŸ­æ™‚é–“å…§æ²’æœ‰å·´å£«', countdownText: '', remarkText: remark || '' };
      }
      const etaD = new Date(etaIso);
      const nowD = new Date(dataTsIso || Date.now());
      const diff = Math.floor((etaD - nowD) / 1000);
      const min = Math.floor(diff / 60);
      const sec = Math.abs(diff % 60);

      let countdown = `${min}åˆ†${sec < 10 ? '0' + sec : sec}ç§’`;
      if (min < -10) countdown = 'çŸ­æ™‚é–“å…§æ²’æœ‰å·´å£«';

      const hrRaw = etaD.getHours();
      const hr = hrRaw > 12 ? hrRaw - 12 : (hrRaw === 0 ? 12 : hrRaw);
      const mm = etaD.getMinutes() < 10 ? '0' + etaD.getMinutes() : etaD.getMinutes();
      const ap = hrRaw >= 12 ? 'PM' : 'AM';

      return {
        timeText: `${hr}:${mm} ${ap}`,
        countdownText: countdown === 'çŸ­æ™‚é–“å…§æ²’æœ‰å·´å£«' ? '' : `è·é›¢æŠµé” ${countdown}`,
        remarkText: remark || 'å¯¦æ™‚ç­æ¬¡',
        isNoService: countdown === 'çŸ­æ™‚é–“å…§æ²’æœ‰å·´å£«'
      };
    }

    function getCurrentLocation() {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('æ­¤ç€è¦½å™¨ä¸æ”¯æ´å®šä½åŠŸèƒ½'));
          return;
        }
        navigator.geolocation.getCurrentPosition(
          (position) => resolve({ latitude: position.coords.latitude, longitude: position.coords.longitude }),
          (error) => {
            let errorMessage = 'ç„¡æ³•ç²å–æ‚¨çš„ä½ç½®';
            switch (error.code) {
              case error.PERMISSION_DENIED: errorMessage = 'ä½ç½®å­˜å–è¢«æ‹’çµ•ï¼Œè«‹æ‰‹å‹•é¸æ“‡å·´å£«ç«™'; break;
              case error.POSITION_UNAVAILABLE: errorMessage = 'ä½ç½®è³‡è¨Šç„¡æ³•å–å¾—ï¼Œè«‹æ‰‹å‹•é¸æ“‡å·´å£«ç«™'; break;
              case error.TIMEOUT: errorMessage = 'ä½ç½®è«‹æ±‚é€¾æ™‚ï¼Œè«‹æ‰‹å‹•é¸æ“‡å·´å£«ç«™'; break;
            }
            reject(new Error(errorMessage));
          },
          { enableHighAccuracy: true, timeout: 10000, maximumAge: 300000 }
        );
      });
    }

    // ---- Providers (KMB / CTB) ----
    const KMB = {
      base: 'https://data.etabus.gov.hk/v1/transport/kmb',
      async fetchStopsMap() {
        const r = await fetch(`${this.base}/stop/`);
        const j = await r.json();
        return j.data.reduce((m, i) => { m[i.stop] = i.name_tc; return m; }, {});
      },
      async fetchRoutes() {
        const r = await fetch(`${this.base}/route/`);
        const j = await r.json();
        return j.data; // array
      },
      async fetchRouteStops(route, direction) {
        const r = await fetch(`${this.base}/route-stop/${route}/${direction}/1`);
        const j = await r.json();
        return j.data || [];
      },
      async fetchStopDetail(stopId) {
        const r = await fetch(`${this.base}/stop/${stopId}`);
        const j = await r.json();
        const d = j.data || {};
        return { stop: stopId, name_tc: d.name_tc, lat: parseFloat(d.lat), long: parseFloat(d.long) };
      },
      async fetchEta(stopId, route) {
        const r = await fetch(`${this.base}/eta/${stopId}/${route}/1`);
        const j = await r.json();
        return j.data || [];
      }
    };

    const CTB = {
      base: 'https://rt.data.gov.hk/v2/transport/citybus',
      companyId: 'CTB',
      async fetchRoutes() {
        const r = await fetch(`${this.base}/route/${this.companyId}`);
        const j = await r.json();
        const data = j.data;
        // API returns either array (route list) or object (single route)
        if (Array.isArray(data)) return data;
        if (data && typeof data === 'object') return [data];
        return [];
      },
      async fetchRouteStops(route, direction) {
        const r = await fetch(`${this.base}/route-stop/${this.companyId}/${route}/${direction}`);
        const j = await r.json();
        return j.data || [];
      },
      _stopCache: new Map(),
      async fetchStopDetail(stopId) {
        if (this._stopCache.has(stopId)) return this._stopCache.get(stopId);
        const r = await fetch(`${this.base}/stop/${stopId}`);
        const j = await r.json();
        const d = j.data || {};
        const detail = { stop: stopId, name_tc: d.name_tc, lat: parseFloat(d.lat), long: parseFloat(d.long) };
        this._stopCache.set(stopId, detail);
        return detail;
      },
      async fetchEta(stopId, route) {
        const r = await fetch(`${this.base}/eta/${this.companyId}/${stopId}/${route}`);
        const j = await r.json();
        return j.data || [];
      }
    };

    // ---- Global state ----
    let kmbStopsMap = {};
    let kmbRoutesData = [];
    let ctbRoutesData = [];

    let kmbRoutesSet = new Set();
    let ctbRoutesSet = new Set();
    let ctbRouteMap = new Map();

    let currentDirection = 'outbound'; // outbound/inbound
    let companyMode = 'AUTO'; // AUTO | KMB | CTB
    let resolvedCompany = null; // actual provider for current route

    function companyLabel(mode) {
      if (mode === 'AUTO') return 'è‡ªå‹•';
      if (mode === 'KMB') return 'KMB';
      if (mode === 'CTB') return 'åŸå·´';
      return mode;
    }

    function resolveCompanyForRoute(route) {
      const inKMB = kmbRoutesSet.has(route);
      const inCTB = ctbRoutesSet.has(route);
      if (!inKMB && !inCTB) return null;

      if (companyMode === 'KMB' && inKMB) return 'KMB';
      if (companyMode === 'CTB' && inCTB) return 'CTB';

      if (inKMB && !inCTB) return 'KMB';
      if (inCTB && !inKMB) return 'CTB';

      // both
      if (companyMode === 'CTB') return 'CTB';
      return 'KMB'; // default when AUTO
    }

    function updateCompanyButtonState(route) {
      const btn = el('toggleCompany');
      if (!route) {
        btn.disabled = true;
        btn.textContent = `ğŸ¢ å…¬å¸: ${companyLabel(companyMode)}`;
        return;
      }
      btn.disabled = false;
      btn.textContent = `ğŸ¢ å…¬å¸: ${companyLabel(companyMode)}`;
    }

    function updateDestinationDisplay(route) {
      const destinationEl = el('destination');
      const toggleBtn = el('toggle');

      if (!route) {
        destinationEl.textContent = 'è«‹å…ˆé¸æ“‡å·´å£«è·¯ç·š';
        destinationEl.className = 'destination-display empty';
        toggleBtn.disabled = true;
        return;
      }

      if (resolvedCompany === 'KMB') {
        const rows = kmbRoutesData.filter(i => i.route === route);
        const currentInfo = rows.find(i => i.bound === (currentDirection === 'outbound' ? 'O' : 'I')) || rows[0];
        if (currentInfo) {
          destinationEl.textContent = `ğŸ¯ ${currentInfo.dest_tc}`;
          destinationEl.className = 'destination-display';
          toggleBtn.disabled = rows.length < 2; // if only one bound
        } else {
          destinationEl.textContent = 'è«‹å…ˆé¸æ“‡å·´å£«è·¯ç·š';
          destinationEl.className = 'destination-display empty';
          toggleBtn.disabled = true;
        }
        return;
      }

      if (resolvedCompany === 'CTB') {
        const info = ctbRouteMap.get(route);
        if (info) {
          const text = (currentDirection === 'outbound') ? info.dest_tc : info.orig_tc;
          destinationEl.textContent = `ğŸ¯ ${text}`;
          destinationEl.className = 'destination-display';
          toggleBtn.disabled = false; // CTB always has two directions conceptually
        } else {
          destinationEl.textContent = 'è«‹å…ˆé¸æ“‡å·´å£«è·¯ç·š';
          destinationEl.className = 'destination-display empty';
          toggleBtn.disabled = true;
        }
        return;
      }

      destinationEl.textContent = 'è«‹å…ˆé¸æ“‡å·´å£«è·¯ç·š';
      destinationEl.className = 'destination-display empty';
      toggleBtn.disabled = true;
    }

    async function autoFindClosestStop(route) {
      const s = el('s');
      if (!route || !resolvedCompany) return;
      if (!s.options || s.options.length <= 1) return;

      try {
        setLoading(true);
        showStatus('ğŸ” æ­£åœ¨è‡ªå‹•å°‹æ‰¾æœ€è¿‘çš„å·´å£«ç«™...', 'info');

        const userLocation = await getCurrentLocation();
        showStatus('ğŸ“ æ­£åœ¨è¨ˆç®—è·é›¢...', 'info');

        let stopsWithCoords = [];
        if (resolvedCompany === 'KMB') {
          const bound = currentDirection; // outbound/inbound
          const routeStops = await KMB.fetchRouteStops(route, bound);
          const stopDetailsPromises = routeStops.map(st => KMB.fetchStopDetail(st.stop).then(d => ({...st, ...d})));
          stopsWithCoords = await Promise.all(stopDetailsPromises);
        } else {
          const bound = currentDirection; // outbound/inbound
          const routeStops = await CTB.fetchRouteStops(route, bound);
          const stopDetailsPromises = routeStops.map(st => CTB.fetchStopDetail(st.stop).then(d => ({...st, ...d})));
          stopsWithCoords = await Promise.all(stopDetailsPromises);
        }

        let closestStop = null;
        let minDistance = Infinity;
        stopsWithCoords.forEach(stop => {
          if (Number.isFinite(stop.lat) && Number.isFinite(stop.long)) {
            const distance = calculateDistance(userLocation.latitude, userLocation.longitude, stop.lat, stop.long);
            if (distance < minDistance) {
              minDistance = distance;
              closestStop = stop;
            }
          }
        });

        if (closestStop) {
          s.value = closestStop.stop;
          s.dispatchEvent(new Event('change'));
          const distanceText = minDistance < 1 ? `${Math.round(minDistance * 1000)}ç±³` : `${minDistance.toFixed(1)}å…¬é‡Œ`;
          showStatus(`âœ… å·²è‡ªå‹•é¸æ“‡æœ€è¿‘çš„å·´å£«ç«™ (è·é›¢: ${distanceText})`, 'success');
        } else {
          throw new Error('ç„¡æ³•æ‰¾åˆ°æœ‰æ•ˆåº§æ¨™çš„å·´å£«ç«™');
        }
      } catch (err) {
        console.error(err);
        showStatus(err.message || 'ç„¡æ³•è‡ªå‹•é¸æ“‡æœ€è¿‘å·´å£«ç«™', 'error');
      } finally {
        setLoading(false);
      }
    }

    document.addEventListener('DOMContentLoaded', async () => {
      const rInput = el('r');
      const infoBox = el('i');
      const stopSelect = el('s');
      const etaBox = el('e');
      const toggleBtn = el('toggle');
      const toggleCompanyBtn = el('toggleCompany');
      const routesDatalist = el('routes');
      const empty = el('empty');

      empty.style.display = 'block';

      setLoading(true);
      showStatus('ğŸ“¦ æ­£åœ¨è¼‰å…¥è·¯ç·šè³‡æ–™ï¼ˆKMB + åŸå·´ï¼‰...', 'info');

      // Load KMB stops & routes, and CTB routes
      const [kmbStops, kmbRoutes, ctbRoutes] = await Promise.all([
        KMB.fetchStopsMap(),
        KMB.fetchRoutes(),
        CTB.fetchRoutes()
      ]);

      kmbStopsMap = kmbStops;
      kmbRoutesData = kmbRoutes;
      ctbRoutesData = ctbRoutes;

      kmbRoutesSet = new Set(kmbRoutesData.map(x => String(x.route).toUpperCase()));
      ctbRoutesSet = new Set(ctbRoutesData.map(x => String(x.route).toUpperCase()));
      ctbRouteMap = new Map(ctbRoutesData.map(x => [String(x.route).toUpperCase(), x]));

      // Populate datalist with union of route numbers
      const union = Array.from(new Set([...kmbRoutesSet, ...ctbRoutesSet])).sort((a,b)=>a.localeCompare(b, undefined, {numeric:true, sensitivity:'base'}));
      union.forEach(rt => routesDatalist.appendChild(makeOption(rt, rt)));

      setLoading(false);

      // Keep uppercase route input
      rInput.addEventListener('input', (event) => {
        const value = event.target.value.toUpperCase();
        if (value !== event.target.value) event.target.value = value;
      });

      // Toggle direction
      toggleBtn.addEventListener('click', () => {
        if (!rInput.value) return;
        currentDirection = currentDirection === 'outbound' ? 'inbound' : 'outbound';
        updateDestinationDisplay(rInput.value);
        update();
      });

      // Toggle company mode: AUTO -> KMB -> CTB -> AUTO
      toggleCompanyBtn.addEventListener('click', () => {
        companyMode = (companyMode === 'AUTO') ? 'KMB' : (companyMode === 'KMB') ? 'CTB' : 'AUTO';
        updateCompanyButtonState(rInput.value);
        if (rInput.value) {
          // Re-resolve company and refresh
          resolvedCompany = resolveCompanyForRoute(rInput.value);
          if (resolvedCompany === null) {
            showStatus('æ‰¾ä¸åˆ°æ­¤è·¯ç·šï¼ˆKMB/åŸå·´ï¼‰', 'error');
            return;
          }
          showStatus(`å·²åˆ‡æ›è‡³ï¼š${companyLabel(companyMode)}ï¼ˆç›®å‰ä½¿ç”¨ï¼š${resolvedCompany}ï¼‰`, 'success');
          updateDestinationDisplay(rInput.value);
          update();
        }
      });

      // Route change handler
      rInput.addEventListener('change', () => {
        const route = rInput.value.toUpperCase();
        rInput.value = route;

        resolvedCompany = resolveCompanyForRoute(route);
        updateCompanyButtonState(route);

        if (!resolvedCompany) {
          // Reset
          updateDestinationDisplay('');
          stopSelect.innerHTML = '<option value="">è«‹å…ˆé¸æ“‡è·¯ç·šå’Œç›®çš„åœ°</option>';
          infoBox.className = 'route-info';
          etaBox.style.display = 'none';
          empty.style.display = 'block';
          showStatus('æ‰¾ä¸åˆ°æ­¤è·¯ç·šï¼ˆKMB/åŸå·´ï¼‰', 'error');
          return;
        }

        // If both exist and AUTO, inform user
        const inK = kmbRoutesSet.has(route);
        const inC = ctbRoutesSet.has(route);
        if (companyMode === 'AUTO' && inK && inC) {
          showStatus('æ­¤è·¯ç·šåŒæ™‚å­˜åœ¨æ–¼ KMB / åŸå·´ã€‚å·²å…ˆä½¿ç”¨ KMBï¼›å¦‚è¦åŸå·´è«‹æŒ‰ã€Œå…¬å¸ã€åˆ‡æ›ã€‚', 'info');
        }

        currentDirection = 'outbound';
        updateDestinationDisplay(route);
        update();
      });

      async function update() {
        const route = rInput.value.toUpperCase();
        if (!route || !resolvedCompany) return;

        setLoading(true);
        empty.style.display = 'none';
        etaBox.style.display = 'none';
        etaBox.innerHTML = '';

        try {
          // Route info box
          if (resolvedCompany === 'KMB') {
            const rows = kmbRoutesData.filter(x => x.route === route);
            const currentInfo = rows.find(i => i.bound === (currentDirection === 'outbound' ? 'O' : 'I')) || rows[0];
            if (currentInfo) {
              infoBox.innerHTML = `
                <h3>è·¯ç·š ${currentInfo.route}</h3>
                <p>ğŸ¢ å…¬å¸: KMB</p>
                <p>ğŸ¯ ç›®çš„åœ°: ${currentDirection === 'outbound' ? currentInfo.dest_tc : (rows.find(i=>i.bound==='I')?.dest_tc || currentInfo.dest_tc)}</p>
              `;
              infoBox.className = 'route-info show';
            } else {
              infoBox.className = 'route-info';
            }

            // Stops
            const bound = currentDirection; // outbound/inbound
            const sd = await KMB.fetchRouteStops(route, bound);
            stopSelect.innerHTML = '';
            sd.sort((a,b)=>Number(a.seq)-Number(b.seq)).forEach(it => {
              stopSelect.appendChild(makeOption(it.stop, `${it.seq}. ${kmbStopsMap[it.stop] || it.stop}`, it.seq));
            });

          } else {
            // CTB
            const info = ctbRouteMap.get(route);
            if (info) {
              const destText = info.dest_tc || info.dest_en || route;
              const origText = info.orig_tc || info.orig_en || '';
              const showTo = (currentDirection === 'outbound') ? destText : origText;
              infoBox.innerHTML = `
                <h3>è·¯ç·š ${route}</h3>
                <p>ğŸ¢ å…¬å¸: åŸå·´ CTB</p>
                <p>ğŸ¯ ç›®çš„åœ°: ${showTo}</p>
              `;
              infoBox.className = 'route-info show';
            } else {
              infoBox.className = 'route-info';
            }

            const bound = currentDirection; // outbound/inbound
            const sd = await CTB.fetchRouteStops(route, bound);
            stopSelect.innerHTML = '';

            // Fetch stop details for names (with cache)
            const details = await Promise.all(sd.map(it => CTB.fetchStopDetail(it.stop)));
            const mapById = new Map(details.map(d => [d.stop, d]));

            sd.sort((a,b)=>Number(a.seq)-Number(b.seq)).forEach(it => {
              const det = mapById.get(it.stop);
              const name = det?.name_tc || it.stop;
              stopSelect.appendChild(makeOption(it.stop, `${it.seq}. ${name}`, it.seq));
            });
          }

          setLoading(false);
          // Auto select nearest stop
          autoFindClosestStop(route);

        } catch (err) {
          console.error(err);
          setLoading(false);
          showStatus(err.message || 'è¼‰å…¥è³‡æ–™æ™‚å‡ºéŒ¯', 'error');
        }
      }

      // Stop change handler
      stopSelect.addEventListener('change', async () => {
        const route = rInput.value.toUpperCase();
        if (!stopSelect.value || !route || !resolvedCompany) {
          etaBox.style.display = 'none';
          empty.style.display = 'block';
          return;
        }

        setLoading(true);
        empty.style.display = 'none';
        etaBox.innerHTML = '';

        try {
          const selectedSeq = Number(stopSelect.options[stopSelect.selectedIndex].dataset.seq || '0');

          if (resolvedCompany === 'KMB') {
            const ed = await KMB.fetchEta(stopSelect.value, route);
            const validEtas = ed.filter(it => Number(it.seq) === selectedSeq);

            if (validEtas.length === 0) {
              etaBox.innerHTML = '<div class="eta-item"><div class="eta-time">æš«ç„¡ç­æ¬¡è³‡è¨Š</div></div>';
            } else {
              validEtas.forEach(it => {
                const rmk = it.rmk_tc || 'å¯¦æ™‚ç­æ¬¡';
                const block = formatEtaBlock(it.eta, it.data_timestamp, rmk);

                if (block.isNoService || block.timeText === 'çŸ­æ™‚é–“å…§æ²’æœ‰å·´å£«') {
                  etaBox.innerHTML += `
                    <div class="eta-item"><div><div class="eta-time">çŸ­æ™‚é–“å…§æ²’æœ‰å·´å£«</div></div></div>
                  `;
                } else {
                  etaBox.innerHTML += `
                    <div class="eta-item"><div>
                      <div class="eta-time">${block.timeText}</div>
                      <div class="eta-countdown">${block.countdownText}</div>
                      <div class="eta-status">${block.remarkText}</div>
                    </div></div>
                  `;
                }
              });
            }

          } else {
            const ed = await CTB.fetchEta(stopSelect.value, route);
            const dirLetter = currentDirection === 'outbound' ? 'O' : 'I';
            const validEtas = ed.filter(it => Number(it.seq) === selectedSeq && String(it.dir).toUpperCase() === dirLetter);

            if (validEtas.length === 0) {
              etaBox.innerHTML = '<div class="eta-item"><div class="eta-time">æš«ç„¡ç­æ¬¡è³‡è¨Š</div></div>';
            } else {
              validEtas.forEach(it => {
                const rmk = it.rmk_tc || it.rmk_en || 'å¯¦æ™‚ç­æ¬¡';
                const block = formatEtaBlock(it.eta, it.data_timestamp, rmk);

                if (block.isNoService || block.timeText === 'çŸ­æ™‚é–“å…§æ²’æœ‰å·´å£«') {
                  etaBox.innerHTML += `
                    <div class="eta-item"><div><div class="eta-time">çŸ­æ™‚é–“å…§æ²’æœ‰å·´å£«</div></div></div>
                  `;
                } else {
                  etaBox.innerHTML += `
                    <div class="eta-item"><div>
                      <div class="eta-time">${block.timeText}</div>
                      <div class="eta-countdown">${block.countdownText}</div>
                      <div class="eta-status">${block.remarkText}</div>
                    </div></div>
                  `;
                }
              });
            }
          }

          etaBox.style.display = 'block';
          setLoading(false);

        } catch (err) {
          console.error(err);
          setLoading(false);
          showStatus(err.message || 'è®€å–åˆ°ç«™æ™‚é–“æ™‚å‡ºéŒ¯', 'error');
        }
      });

      // Initial button label
      updateCompanyButtonState('');
    });
  </script>
</body>
</html>
